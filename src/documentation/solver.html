<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>solver API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>solver</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="solver.EquationOfState"><code class="flex name class">
<span>class <span class="ident">EquationOfState</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an equation of state.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>number_densities</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores number densities in cm^-3.</dd>
<dt><strong><code>pressures</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores pressures in dyne/cm^2.</dd>
<dt><strong><code>energy_densities</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores energy densities in erg/cm^3.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>load_from_file(file_path)
Read data from a file and store number densities, pressures and energy densities in corresponding NumPy arrays.
plot()
Plot energy densities versus pressure.
interpolate()
Interpolate using cubic spline and return the equation of state in the form of energy density as a function of pressure.
get()
Return NumPy arrays containing pressure and energy density.</p>
<p>Initialise NumPy arrays to store number densities, pressures and energy densities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EquationOfState:
    &#34;&#34;&#34;
    Class to represent an equation of state.

    Attributes
    ----------
    number_densities : NumPy array
        NumPy array that stores number densities in cm^-3.
    pressures : NumPy array
        NumPy array that stores pressures in dyne/cm^2.
    energy_densities : NumPy array
        NumPy array that stores energy densities in erg/cm^3.

    Methods
    -------
    load_from_file(file_path)
        Read data from a file and store number densities, pressures and energy densities in corresponding NumPy arrays.
    plot()
        Plot energy densities versus pressure.
    interpolate()
        Interpolate using cubic spline and return the equation of state in the form of energy density as a function of pressure.
    get()
        Return NumPy arrays containing pressure and energy density.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initialise NumPy arrays to store number densities, pressures and energy densities.
        &#34;&#34;&#34;
        self.number_densities = np.array([])
        self.pressures = np.array([])
        self.energy_densities = np.array([])

    def load_from_file(self, file_path):
        &#34;&#34;&#34;
        Open file given its path, read data and store quantities in corresponding NumPy arrays. The first row is skipped because it is the header. The delimiter must be comma for csv files. In the first column there must be number densities in 1/cm^3, in the second column there must be pressures in dyne/cm^2, in the third column there must be energy densities in erg/cm^3.

        Parameters
        ----------
        file_path : str
            Path of the file containing number densities, pressures and energy densities in respective columns.

        Raises
        ------
        InputError
            The file cannot be opened.
        ValueError
            The file is empty.
            Pressures are not strictly increasing.
        &#34;&#34;&#34;
        try:
            data = np.loadtxt(file_path, delimiter=&#34;,&#34;, skiprows=1)
            self.number_densities = np.append(self.number_densities, data[:, 0])
            self.pressures = np.append(self.pressures, data[:, 1])
            self.energy_densities = np.append(self.energy_densities, data[:, 2])
        except Exception as ex:
            raise IOError(f&#34;Failed to load file {file_path}: {ex}&#34;)

        if self.pressures.size == 0 or self.energy_densities.size == 0:
            raise ValueError(&#34;File is empty.&#34;)

        # Ensure pressures are strictly increasing for interpolation
        is_sorted = np.all(np.diff(self.pressures) &gt; 0)
        if not is_sorted:
            raise ValueError(&#34;Pressures must be strictly increasing.&#34;)

    def plot(self):
        &#34;&#34;&#34;
        Plot energy density versus pressure using logarithmic scale for both x and y axis with a grid.

        Raises
        ------
        ValueError
            No data is loaded to plot.
        &#34;&#34;&#34;
        if self.pressures.size == 0 or self.energy_densities.size == 0:
            raise ValueError(&#34;No data loaded.&#34;)

        plt.plot(self.pressures, self.energy_densities)
        plt.ylabel(&#34;Energy Density ($erg / cm^3$)&#34;)
        plt.yscale(&#34;log&#34;)
        plt.xlabel(&#34;Pressure ($dyne / cm^2$)&#34;)
        plt.xscale(&#34;log&#34;)
        plt.grid(True)
        plt.show()

    def interpolate(self):
        &#34;&#34;&#34;
        Interpolate pressures and energy densities into an equation of state using cubic spline (imported from SciPy).

        Returns
        -------
        CubicSpline
            CubicSpline representation of the equation of state, which gives energy density as output once pressure is given as input.

        Raises
        ------
        ValueError
            No data is loaded to interpolate.
        &#34;&#34;&#34;
        if self.pressures.size == 0 or self.energy_densities.size == 0:
            raise ValueError(&#34;No data loaded.&#34;)

        eos = CubicSpline(self.pressures, self.energy_densities)
        return eos

    def get(self):
        &#34;&#34;&#34;
        Return NumPy arrays containing pressures and energy densities.

        Returns
        -------
        tuple
            NumPy arrays of pressures and energy densities.
        &#34;&#34;&#34;
        return self.pressures, self.energy_densities</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.EquationOfState.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return NumPy arrays containing pressures and energy densities.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>NumPy arrays of pressures and energy densities.</dd>
</dl></div>
</dd>
<dt id="solver.EquationOfState.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate pressures and energy densities into an equation of state using cubic spline (imported from SciPy).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CubicSpline</code></dt>
<dd>CubicSpline representation of the equation of state, which gives energy density as output once pressure is given as input.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is loaded to interpolate.</dd>
</dl></div>
</dd>
<dt id="solver.EquationOfState.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Open file given its path, read data and store quantities in corresponding NumPy arrays. The first row is skipped because it is the header. The delimiter must be comma for csv files. In the first column there must be number densities in 1/cm^3, in the second column there must be pressures in dyne/cm^2, in the third column there must be energy densities in erg/cm^3.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of the file containing number densities, pressures and energy densities in respective columns.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InputError</code></dt>
<dd>The file cannot be opened.</dd>
<dt><code>ValueError</code></dt>
<dd>The file is empty.
Pressures are not strictly increasing.</dd>
</dl></div>
</dd>
<dt id="solver.EquationOfState.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot energy density versus pressure using logarithmic scale for both x and y axis with a grid.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is loaded to plot.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="solver.SolverRangePressure"><code class="flex name class">
<span>class <span class="ident">SolverRangePressure</span></span>
<span>(</span><span>eos, relativity_corrections=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to solve numerically the system of ordinary differential equations given a range of initial pressures.
It uses the class SolverSinglePressure for each initial pressure.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>eos</code></strong> :&ensp;<code>CubicSpline</code></dt>
<dd>A CubicSpline representation of the equation of state.</dd>
<dt><strong><code>relativity_corrections</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.</dd>
<dt><strong><code>radii</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores radii in km.</dd>
<dt><strong><code>masses</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores masses in solar masses.</dd>
<dt><strong><code>initial_pressures</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores initial pressures in dyne/cm^2.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>solve(step_r, initial_pressures)
Integrate the system until pressure drops to zero given the initial pressure and radius step. Store radii, masses and pressures in corresponding NumPy arrays.
print_max_mass()
Print the maximum mass, its radius and central pressure.
get()
Return NumPy arrays containing radius, mass and initial pressure.
plot_MRvsP()
Plot mass and radius versus initial pressure.
plot_RvsM()
Plot radius versus mass.</p>
<p>Take an equation of state and an option for relativity corrections and copy them to attributes of the class.
Initialise NumPy arrays to store radii in km, pressures in dyne/cm^2 and masses in solar masses.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eos</code></strong> :&ensp;<code>CubicSpline</code></dt>
<dd>A CubicSpline representation of the equation of state.</dd>
<dt><strong><code>relativity_corrections</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolverRangePressure:
    &#34;&#34;&#34;
    Class to solve numerically the system of ordinary differential equations given a range of initial pressures.
    It uses the class SolverSinglePressure for each initial pressure.

    Attributes
    ----------
    eos : CubicSpline
        A CubicSpline representation of the equation of state.
    relativity_corrections : bool
        A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.
    radii : NumPy array
        NumPy array that stores radii in km.
    masses : NumPy array
        NumPy array that stores masses in solar masses.
    initial_pressures : NumPy array
        NumPy array that stores initial pressures in dyne/cm^2.

    Methods
    -------
    solve(step_r, initial_pressures)
        Integrate the system until pressure drops to zero given the initial pressure and radius step. Store radii, masses and pressures in corresponding NumPy arrays.
    print_max_mass()
        Print the maximum mass, its radius and central pressure.
    get()
        Return NumPy arrays containing radius, mass and initial pressure.
    plot_MRvsP()
        Plot mass and radius versus initial pressure.
    plot_RvsM()
        Plot radius versus mass.
    &#34;&#34;&#34;

    def __init__(self, eos, relativity_corrections=True):
        &#34;&#34;&#34;
        Take an equation of state and an option for relativity corrections and copy them to attributes of the class.
        Initialise NumPy arrays to store radii in km, pressures in dyne/cm^2 and masses in solar masses.

        Parameters
        ----------
        eos : CubicSpline
            A CubicSpline representation of the equation of state.
        relativity_corrections : bool
            A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.
        &#34;&#34;&#34;
        self.eos = eos
        self.relativity_corrections = relativity_corrections

        self.radii = np.array([])
        self.masses = np.array([])
        self.initial_pressures = np.array([])

    def solve(self, step_r, initial_pressures):
        &#34;&#34;&#34;
        Solve the system for a range of initial pressures. Using the class SolverSinglePressure, compute the mass and the radius and store them for each initial pressure.

        Parameters
        ----------
        step_r : float
            Radius step in cm.
        initial_pressures : NumPy array
            NumPy array of initial pressures in dyne/cm^2.

        Raises
        -------
        ValueError
            If radius step is negative.
            If initial pressure is negative.
        &#34;&#34;&#34;
        if step_r &lt; 0:
            raise ValueError(&#34;Radius step cannot be negative.&#34;)

        if initial_pressures.any() &lt; 0:
            raise ValueError(&#34;Initial pressures cannot be negative.&#34;)

        self.initial_pressures = np.append(self.initial_pressures, initial_pressures)

        for p0 in initial_pressures:
            # Solve for a single pressure p0
            self.solver_single_p = SolverSinglePressure(
                self.eos, self.relativity_corrections
            )
            self.solver_single_p.solve(step_r, p0)

            # Save mass and radius
            r, m, p = self.solver_single_p.get()
            self.masses = np.append(self.masses, m[-1])
            self.radii = np.append(self.radii, r[-1])

    def print_max_mass(self):
        &#34;&#34;&#34;
        Print the maximum mass, its corresponding radius and central pressure.

        Raises
        -------
        ValueError
            No data is computed to print.
        &#34;&#34;&#34;
        if (
            self.radii.size == 0
            or self.masses.size == 0
            or self.initial_pressures.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        index = np.argmax(self.masses)  # Get index of maximum mass
        print(&#34;The maximum mass is M =&#34;, round(self.masses[index], 3), &#34;M_sun, &#34;)
        print(&#34;which corresponds to a radius of R =&#34;, round(self.radii[index], 3), &#34;km&#34;)
        print(
            &#34;and a central pressure of P =&#34;,
            round(self.initial_pressures[index], 3),
            &#34;dyne/cm^2&#34;,
        )

    def get(self):
        &#34;&#34;&#34;
        Return the NumPy arrays of radius, mass and initial pressure.

        Returns
        --------
        tuple
            NumPy array of radius in km, mass in solar masses and initial pressure in dyne/cm^2.

        Raises
        ------
        ValueError
            No data is computed to get
        &#34;&#34;&#34;
        if (
            self.radii.size == 0
            or self.masses.size == 0
            or self.initial_pressures.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        return self.radii, self.masses, self.initial_pressures

    def plot_MRvsP(self):
        &#34;&#34;&#34;
        Plot mass and radius versus initial pressure.
        Show two subplots: radius versus initial pressure and mass versus initial pressure in logarithmic scal for the x axis with a grid.

        Raises
        -------
        ValueError
            No data is computed to plot
        &#34;&#34;&#34;
        if (
            self.radii.size == 0
            or self.masses.size == 0
            or self.initial_pressures.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        fig, axs = plt.subplots(1, 2, figsize=(11, 5))
        axs[0].plot(self.initial_pressures, self.radii)
        axs[0].set_xlabel(&#34;Pressure ($dyne / cm^2$)&#34;)
        axs[0].set_ylabel(&#34;Radius ($km$)&#34;)
        axs[0].set_xscale(&#34;log&#34;)
        axs[0].grid(True)
        axs[1].plot(self.initial_pressures, self.masses)
        axs[1].set_xlabel(&#34;Pressure ($dyne / cm^2$)&#34;)
        axs[1].set_ylabel(&#34;Mass ($M_{\\odot}$)&#34;)
        axs[1].set_xscale(&#34;log&#34;)
        axs[1].grid(True)
        plt.show()

    def plot_RvsM(self):
        &#34;&#34;&#34;
        Plot radius versus mass with a grid.

        Raises
        ------
        ValueError
            No data is computed to plot
        &#34;&#34;&#34;
        if (
            self.radii.size == 0
            or self.masses.size == 0
            or self.initial_pressures.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        plt.plot(self.radii, self.masses)
        plt.xlabel(&#34;Radius ($km$)&#34;)
        plt.ylabel(&#34;Mass ($M_{\\odot}$)&#34;)
        plt.grid(True)
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.SolverRangePressure.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the NumPy arrays of radius, mass and initial pressure.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>NumPy array of radius in km, mass in solar masses and initial pressure in dyne/cm^2.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to get</dd>
</dl></div>
</dd>
<dt id="solver.SolverRangePressure.plot_MRvsP"><code class="name flex">
<span>def <span class="ident">plot_MRvsP</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot mass and radius versus initial pressure.
Show two subplots: radius versus initial pressure and mass versus initial pressure in logarithmic scal for the x axis with a grid.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to plot</dd>
</dl></div>
</dd>
<dt id="solver.SolverRangePressure.plot_RvsM"><code class="name flex">
<span>def <span class="ident">plot_RvsM</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot radius versus mass with a grid.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to plot</dd>
</dl></div>
</dd>
<dt id="solver.SolverRangePressure.print_max_mass"><code class="name flex">
<span>def <span class="ident">print_max_mass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the maximum mass, its corresponding radius and central pressure.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to print.</dd>
</dl></div>
</dd>
<dt id="solver.SolverRangePressure.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, step_r, initial_pressures)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the system for a range of initial pressures. Using the class SolverSinglePressure, compute the mass and the radius and store them for each initial pressure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>step_r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius step in cm.</dd>
<dt><strong><code>initial_pressures</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array of initial pressures in dyne/cm^2.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If radius step is negative.
If initial pressure is negative.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="solver.SolverSinglePressure"><code class="flex name class">
<span>class <span class="ident">SolverSinglePressure</span></span>
<span>(</span><span>eos, relativity_corrections=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to solve numerically the system of ordinary differential equations given a single initial pressure.
Implement the 4th-order Runge-Kutta with a breaking condition when the pressure becomes zero or negative, because it means that the surface of the object is reached.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>radii</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores radii in km.</dd>
<dt><strong><code>masses</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores masses in solar masses.</dd>
<dt><strong><code>pressures</code></strong> :&ensp;<code>NumPy array</code></dt>
<dd>NumPy array that stores pressures in dyne/cm^2.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>runge_kutta_4th_step(r, dr, p, m)
Implement the Runge-Kutta 4th order algorithm for a single step to solve numerically a system of two differential equations, according to current pressure, mass, radius and radius step.
solve(step_r, p0)
Solve the system until pressure drops to zero given the initial pressure and radius step. Store radii, masses and pressures in corresponding NumPy arrays.
print_mass_radius()
Print the mass and the radius of the object.
get()
Return radius, mass and pressure NumPy arrays.
plot()
Plot mass and radius versus pressure.</p>
<p>Initialize the class TOVSystem with an equation of state and an option for relativity corrections.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eos</code></strong> :&ensp;<code>CubicSpline</code></dt>
<dd>A CubicSpline representation of the equation of state.</dd>
<dt><strong><code>relativity_corrections</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolverSinglePressure:
    &#34;&#34;&#34;
    Class to solve numerically the system of ordinary differential equations given a single initial pressure.
    Implement the 4th-order Runge-Kutta with a breaking condition when the pressure becomes zero or negative, because it means that the surface of the object is reached.

    Attributes
    ----------
    radii : NumPy array
        NumPy array that stores radii in km.
    masses : NumPy array
        NumPy array that stores masses in solar masses.
    pressures : NumPy array
        NumPy array that stores pressures in dyne/cm^2.

    Methods
    -------
    runge_kutta_4th_step(r, dr, p, m)
        Implement the Runge-Kutta 4th order algorithm for a single step to solve numerically a system of two differential equations, according to current pressure, mass, radius and radius step.
    solve(step_r, p0)
        Solve the system until pressure drops to zero given the initial pressure and radius step. Store radii, masses and pressures in corresponding NumPy arrays.
    print_mass_radius()
        Print the mass and the radius of the object.
    get()
        Return radius, mass and pressure NumPy arrays.
    plot()
        Plot mass and radius versus pressure.
    &#34;&#34;&#34;

    def __init__(self, eos, relativity_corrections=True):
        &#34;&#34;&#34;
        Initialize the class TOVSystem with an equation of state and an option for relativity corrections.

        Parameters
        ----------
        eos : CubicSpline
            A CubicSpline representation of the equation of state.
        relativity_corrections : bool
            A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is considered, if False the Netwonian equation is considered.
        &#34;&#34;&#34;
        self.system = TOVSystem(eos, relativity_corrections)

    def runge_kutta_4th_step(self, r, dr, p, m):
        &#34;&#34;&#34;
        Perform a single step of the 4th-order Runge-Kutta algorithm. Given the current radius, pressure, mass and radius step, compute the 4 coefficients of the algorithm, using the equations in the methods of TOVSystem, and then compute and return the new calculated value of pressure and mass.

        Parameters
        ----------
        r : float
            Current radius in cm.
        dr : float
            Radius step in cm.
        p : float
            Current pressure in dyne/cm^2.
        m : float
            Current mass in g.

        Returns
        -------
        tuple
            NumPy arrays of pressures and masses.
        &#34;&#34;&#34;
        kp_1 = self.system.dpdr(r, p, m) * dr
        km_1 = self.system.dmdr(r, p, m) * dr

        kp_2 = self.system.dpdr(r + dr / 2, p + kp_1 / 2, m + km_1 / 2) * dr
        km_2 = self.system.dmdr(r + dr / 2, p + kp_1 / 2, m + km_1 / 2) * dr

        kp_3 = self.system.dpdr(r + dr / 2, p + kp_2 / 2, m + km_2 / 2) * dr
        km_3 = self.system.dmdr(r + dr / 2, p + kp_2 / 2, m + km_2 / 2) * dr

        kp_4 = self.system.dpdr(r + dr, p + kp_3, m + km_3) * dr
        km_4 = self.system.dmdr(r + dr, p + kp_3, m + km_3) * dr

        p_new = p + (kp_1 + 2 * kp_2 + 2 * kp_3 + kp_4) / 6
        m_new = m + (km_1 + 2 * km_2 + 2 * km_3 + km_4) / 6

        return p_new, m_new

    def solve(self, step_r, p0):
        &#34;&#34;&#34;
        Apply the 4th-order Runge-Kutta step using a while loop for the given initial pressure until pressure drops to zero. For every iteration, update the radius, pressure and mass values in the corresponding NumPy arrays. Change unit of measure of mass from g to solar masses and radius from cm to km.

        Parameters
        ----------
        step_r : float
            Radius step in cm.
        p0 : float
            Initial central pressure in dyne/cm^2.

        Raises
        ------
        ValueError
            If radius step is negative.
            If initial pressure is negative.
        &#34;&#34;&#34;
        if step_r &lt; 0:
            raise ValueError(&#34;Radius step cannot be negative.&#34;)

        if p0 &lt; 0:
            raise ValueError(&#34;Initial pressure cannot be negative.&#34;)

        # Initial conditions for the Cauchy problem
        p0 = p0
        m0 = 1e-6  # Small initial mass to prevent division by zero
        r0 = 1e-6  # Small initial radius to avoid division by zero

        # Initialize NumPy arrays with the initial conditions
        self.r_values = np.array([r0])
        self.p_values = np.array([p0])
        self.m_values = np.array([m0])

        pressure_is_negative = False

        while not pressure_is_negative:
            # Take last values
            r = self.r_values[-1]
            p = self.p_values[-1]
            m = self.m_values[-1]

            # Find new values using 4-th order Runge-Kutta algorithm
            p_new, m_new = self.runge_kutta_4th_step(r, step_r, p, m)
            r_new = r + step_r

            # Check if pressure is zero or negative
            if p_new &lt;= 0:
                pressure_is_negative = True  # Condition to break the while loop

            # Add new values to the arrays
            self.r_values = np.append(self.r_values, r_new)
            self.p_values = np.append(self.p_values, p_new)
            self.m_values = np.append(self.m_values, m_new)

        # Convert radius to km and mass to solar masses
        self.r_values = self.r_values / km
        self.m_values = self.m_values / m_sun

    def print_mass_radius(self):
        &#34;&#34;&#34;
        Print the radius in km and mass in solar masses of the object, rounded to fourth significant digits.

        Raises
        ------
        ValueError
            No data is computed to print.
        &#34;&#34;&#34;
        if (
            self.r_values.size == 0
            or self.p_values.size == 0
            or self.m_values.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        print(&#34;The radius is R =&#34;, round(self.r_values[-1], 4), &#34;km&#34;)
        print(&#34;The mass is M =&#34;, round(self.m_values[-1], 4), &#34;M_sun&#34;)

    def get(self):
        &#34;&#34;&#34;
        Return radius, mass and pressure NumPy arrays.

        Returns
        --------
        tuple
            NumPy array of radius in km, mass in solar masses and pressures in dyne/cm^2.

        Raises
        ------
        ValueError
            No data is computed to get.
        &#34;&#34;&#34;
        if (
            self.r_values.size == 0
            or self.p_values.size == 0
            or self.m_values.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        return self.r_values, self.m_values, self.p_values

    def plot(self):
        &#34;&#34;&#34;
        Plot mass and radius versus pressure.
        Show two subplots: radius versus pressure and mass versus pressure with a grid.

        Raises
        -------
        ValueError
            No data is computed to plot.
        &#34;&#34;&#34;
        if (
            self.r_values.size == 0
            or self.p_values.size == 0
            or self.m_values.size == 0
        ):
            raise ValueError(&#34;No data is computed.&#34;)

        fig, axs = plt.subplots(1, 2, figsize=(11, 5))
        axs[0].plot(self.r_values, self.p_values)
        axs[0].set_xlabel(&#34;Radius ($km$)&#34;)
        axs[0].set_ylabel(&#34;Pressure ($dyne / cm^2$)&#34;)
        axs[0].grid(True)
        axs[1].plot(self.r_values, self.m_values)
        axs[1].set_xlabel(&#34;Radius ($km$)&#34;)
        axs[1].set_ylabel(&#34;Mass ($M_{\\odot}$)&#34;)
        axs[1].grid(True)
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.SolverSinglePressure.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return radius, mass and pressure NumPy arrays.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>NumPy array of radius in km, mass in solar masses and pressures in dyne/cm^2.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to get.</dd>
</dl></div>
</dd>
<dt id="solver.SolverSinglePressure.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot mass and radius versus pressure.
Show two subplots: radius versus pressure and mass versus pressure with a grid.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to plot.</dd>
</dl></div>
</dd>
<dt id="solver.SolverSinglePressure.print_mass_radius"><code class="name flex">
<span>def <span class="ident">print_mass_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the radius in km and mass in solar masses of the object, rounded to fourth significant digits.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data is computed to print.</dd>
</dl></div>
</dd>
<dt id="solver.SolverSinglePressure.runge_kutta_4th_step"><code class="name flex">
<span>def <span class="ident">runge_kutta_4th_step</span></span>(<span>self, r, dr, p, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a single step of the 4th-order Runge-Kutta algorithm. Given the current radius, pressure, mass and radius step, compute the 4 coefficients of the algorithm, using the equations in the methods of TOVSystem, and then compute and return the new calculated value of pressure and mass.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Current radius in cm.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius step in cm.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Current pressure in dyne/cm^2.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Current mass in g.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>NumPy arrays of pressures and masses.</dd>
</dl></div>
</dd>
<dt id="solver.SolverSinglePressure.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, step_r, p0)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the 4th-order Runge-Kutta step using a while loop for the given initial pressure until pressure drops to zero. For every iteration, update the radius, pressure and mass values in the corresponding NumPy arrays. Change unit of measure of mass from g to solar masses and radius from cm to km.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>step_r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius step in cm.</dd>
<dt><strong><code>p0</code></strong> :&ensp;<code>float</code></dt>
<dd>Initial central pressure in dyne/cm^2.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If radius step is negative.
If initial pressure is negative.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="solver.TOVSystem"><code class="flex name class">
<span>class <span class="ident">TOVSystem</span></span>
<span>(</span><span>eos, relativity_corrections=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent the system of ordinary differential equations for a spherically symmetric physical object
which is in static gravitational equilibrium. The system is composed in 3 equations: the mass equation, the pressure equation
and the equation of state. The pressure equation can be either Newtonian or relativistic (the latter called properly TOV equation).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>eos</code></strong> :&ensp;<code>CubicSpline</code></dt>
<dd>A CubicSpline representation of the equation of state.</dd>
<dt><strong><code>relativity_corrections</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is used, if False the Newtonian equation is used.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>check_physical_constraints(r, p, m)
Control if physical quantities, like mass, pressure and radius, are positive.
dmdr(r, p, m)
Compute and return the mass equation accordingly to current radius, pressure and mass.
dpdr(r, p, m)
Compute and return the pressure equation accordingly to current radius, pressure, mass. It can consider relativity corrections if attribute relativity_corrections is True.</p>
<p>Take an equation of state and an option for relativity corrections and copy them as attributes of the class.</p>
<p>Parameters:
eos : EquationOfState
A CubicSpline representation of the equation of state.
relativity_corrections : bool
A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is used, if False the Netwonian equation is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TOVSystem:
    &#34;&#34;&#34;
    Class to represent the system of ordinary differential equations for a spherically symmetric physical object
    which is in static gravitational equilibrium. The system is composed in 3 equations: the mass equation, the pressure equation
    and the equation of state. The pressure equation can be either Newtonian or relativistic (the latter called properly TOV equation).

    Attributes
    ----------
    eos : CubicSpline
        A CubicSpline representation of the equation of state.
    relativity_corrections : bool
        A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is used, if False the Newtonian equation is used.

    Methods
    -------
    check_physical_constraints(r, p, m)
        Control if physical quantities, like mass, pressure and radius, are positive.
    dmdr(r, p, m)
        Compute and return the mass equation accordingly to current radius, pressure and mass.
    dpdr(r, p, m)
        Compute and return the pressure equation accordingly to current radius, pressure, mass. It can consider relativity corrections if attribute relativity_corrections is True.
    &#34;&#34;&#34;

    def __init__(self, eos, relativity_corrections=True):
        &#34;&#34;&#34;
        Take an equation of state and an option for relativity corrections and copy them as attributes of the class.

        Parameters:
        eos : EquationOfState
            A CubicSpline representation of the equation of state.
        relativity_corrections : bool
            A Boolean variable to determined whether to include general relativity corrections. If True the TOV equation is used, if False the Netwonian equation is used.
        &#34;&#34;&#34;
        self.eos = eos
        self.relativity_corrections = relativity_corrections

    def check_physical_constraints(self, r, p, m):
        &#34;&#34;&#34;
        Check the physical constraints for radius, pressure and mass, which must be all positive. When pressure is negative, return False to signal that the surface of the object is reached and integration has to stop.

        Parameters
        ----------
        r : float
          Radius in cm.
        p : float
          Pressure in dyne/cm^2.
        m : float
          Mass in g.

        Raises
        ------
        ValueError
            If radius is negative.
            If mass is negative.

        Returns
        -------
        bool
            True if all physical constraints are satisfied, False if pressure is negative.
        &#34;&#34;&#34;
        # Stop if pressure is negative (indicating that we are at the surface)
        if p &lt; 0:
            return False

        if r &lt; 0:
            raise ValueError(&#34;Radius cannot be negative.&#34;)

        if m &lt; 0:
            raise ValueError(&#34;Mass cannot be negative.&#34;)

        return True

    def dmdr(self, r, p, m):
        &#34;&#34;&#34;
        Compute the mass equation (dm/dr) based on the current radius, pressure and mass.

        Parameters
        ---------
        r : float
          Radius in cm.
        p : float
          Pressure in dyne/cm^2.
        m : float
          Mass in g.

        Returns
        -------
        float
            Mass equation of the system (dm/dr).
        &#34;&#34;&#34;
        if not self.check_physical_constraints(r, p, m):
            return 0

        e = self.eos(p)  # Get energy density from equation of state
        dmdr = 4 * np.pi * r**2 * e / c**2
        return dmdr

    def dpdr(self, r, p, m):
        &#34;&#34;&#34;
        Compute the pressure equation (dp/dr) based on the current radius, pressure and mass.
        If relativity corrections are included, return the TOV equation, otherwise return the Newtonian pressure equation.

        Parameters
        ----------
        r : float
            Radius in cm.
        p : float
          Pressure in dyne/cm^2.
        m : float
            Mass in g.

        Returns
        -------
        float
            Pressure equation of the system (dp/dr).
        &#34;&#34;&#34;
        # If pressure is negative, we are at the surface and return 0
        if not self.check_physical_constraints(r, p, m):
            return 0

        e = self.eos(p)  # Get energy density from equation of state

        if self.relativity_corrections:
            first_term = G * e * m / c**2 / r**2
            second_term = 1 + p / e
            third_term = 1 + 4 * np.pi * r**3 * p / m / c**2
            fourth_term = (1 - 2 * G * m / c**2 / r) ** (-1)
            dpdr = -first_term * second_term * third_term * fourth_term  # TOV equation
        else:
            dpdr = -G / c**2 / r**2 * m * e  # Newtonian pressure equation

        return dpdr</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.TOVSystem.check_physical_constraints"><code class="name flex">
<span>def <span class="ident">check_physical_constraints</span></span>(<span>self, r, p, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the physical constraints for radius, pressure and mass, which must be all positive. When pressure is negative, return False to signal that the surface of the object is reached and integration has to stop.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Radius in cm.</dt>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Pressure in dyne/cm^2.</dt>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Mass in g.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If radius is negative.
If mass is negative.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if all physical constraints are satisfied, False if pressure is negative.</dd>
</dl></div>
</dd>
<dt id="solver.TOVSystem.dmdr"><code class="name flex">
<span>def <span class="ident">dmdr</span></span>(<span>self, r, p, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mass equation (dm/dr) based on the current radius, pressure and mass.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Radius in cm.</dt>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Pressure in dyne/cm^2.</dt>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Mass in g.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mass equation of the system (dm/dr).</dd>
</dl></div>
</dd>
<dt id="solver.TOVSystem.dpdr"><code class="name flex">
<span>def <span class="ident">dpdr</span></span>(<span>self, r, p, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the pressure equation (dp/dr) based on the current radius, pressure and mass.
If relativity corrections are included, return the TOV equation, otherwise return the Newtonian pressure equation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius in cm.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Pressure in dyne/cm^2.</dt>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Mass in g.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Pressure equation of the system (dp/dr).</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="solver.EquationOfState" href="#solver.EquationOfState">EquationOfState</a></code></h4>
<ul class="">
<li><code><a title="solver.EquationOfState.get" href="#solver.EquationOfState.get">get</a></code></li>
<li><code><a title="solver.EquationOfState.interpolate" href="#solver.EquationOfState.interpolate">interpolate</a></code></li>
<li><code><a title="solver.EquationOfState.load_from_file" href="#solver.EquationOfState.load_from_file">load_from_file</a></code></li>
<li><code><a title="solver.EquationOfState.plot" href="#solver.EquationOfState.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="solver.SolverRangePressure" href="#solver.SolverRangePressure">SolverRangePressure</a></code></h4>
<ul class="">
<li><code><a title="solver.SolverRangePressure.get" href="#solver.SolverRangePressure.get">get</a></code></li>
<li><code><a title="solver.SolverRangePressure.plot_MRvsP" href="#solver.SolverRangePressure.plot_MRvsP">plot_MRvsP</a></code></li>
<li><code><a title="solver.SolverRangePressure.plot_RvsM" href="#solver.SolverRangePressure.plot_RvsM">plot_RvsM</a></code></li>
<li><code><a title="solver.SolverRangePressure.print_max_mass" href="#solver.SolverRangePressure.print_max_mass">print_max_mass</a></code></li>
<li><code><a title="solver.SolverRangePressure.solve" href="#solver.SolverRangePressure.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="solver.SolverSinglePressure" href="#solver.SolverSinglePressure">SolverSinglePressure</a></code></h4>
<ul class="">
<li><code><a title="solver.SolverSinglePressure.get" href="#solver.SolverSinglePressure.get">get</a></code></li>
<li><code><a title="solver.SolverSinglePressure.plot" href="#solver.SolverSinglePressure.plot">plot</a></code></li>
<li><code><a title="solver.SolverSinglePressure.print_mass_radius" href="#solver.SolverSinglePressure.print_mass_radius">print_mass_radius</a></code></li>
<li><code><a title="solver.SolverSinglePressure.runge_kutta_4th_step" href="#solver.SolverSinglePressure.runge_kutta_4th_step">runge_kutta_4th_step</a></code></li>
<li><code><a title="solver.SolverSinglePressure.solve" href="#solver.SolverSinglePressure.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="solver.TOVSystem" href="#solver.TOVSystem">TOVSystem</a></code></h4>
<ul class="">
<li><code><a title="solver.TOVSystem.check_physical_constraints" href="#solver.TOVSystem.check_physical_constraints">check_physical_constraints</a></code></li>
<li><code><a title="solver.TOVSystem.dmdr" href="#solver.TOVSystem.dmdr">dmdr</a></code></li>
<li><code><a title="solver.TOVSystem.dpdr" href="#solver.TOVSystem.dpdr">dpdr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
